<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Información del Digimon</title>
  <link rel="stylesheet" href="https://cdn.simplecss.org/simple.css"/>
  <style>
/* Estilos base */
.container {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 2rem;
  width: 100%;
  max-width: 1200px;
  margin: 0 auto;
}
.top-section {
  display: flex;
  flex-direction: row;
  align-items: flex-start;
  gap: 2rem;
  width: 100%;
}
.digimon-image {
  flex: 1;
  text-align: center;
  min-width: 300px;
}

/* Estilos mejorados para las imágenes de Digimon */
.digimon-image img {
  width: 280px !important;
  height: 280px !important;
  object-fit: contain;
  border: 2px solid transparent;
  border-radius: 12px;
  background-color: transparent;
  padding: 10px;
  box-shadow: 0 4px 8px rgba(0,0,0,0.1);
  transition: transform 0.2s ease;
  max-width: 100%;
  height: auto;
}

/* Efecto hover para las imágenes */
.digimon-image img:hover {
  transform: scale(1.05);
  box-shadow: 0 6px 12px rgba(0,0,0,0.15);
}

/* Placeholder mejorado */
#imagePlaceholder {
  width: 280px;
  height: 280px;
  margin: 0 auto;
  display: flex;
  align-items: center;
  justify-content: center;
  background: linear-gradient(135deg, #f0f0f0 0%, #e0e0e0 100%);
  border: 2px dashed #ccc;
  border-radius: 12px;
  color: #666;
  font-weight: 500;
  text-align: center;
  max-width: 100%;
}

.digimon-tables {
  flex: 2;
  min-width: 0;
  overflow-x: auto;
}

.digimon-tables.full-width {
  width: 100%;
  flex: none;
}

/* ESTILOS DE TABLA MEJORADOS */
table {
  margin-bottom: 2rem;
  width: 100%;
  border-collapse: collapse;
  table-layout: auto; /* Cambiado de fixed a auto */
}

table th,
table td {
  padding: 0.4rem;
  text-align: center;
  border: 1px solid #ddd;
  word-wrap: break-word;
  hyphens: auto;
  overflow-wrap: break-word;
  white-space: normal;
  line-height: 1.3;
  font-size: 0.9rem;
  vertical-align: middle;
}

table th {
  font-weight: bold;
}

select:disabled {
  opacity: 0.5;
}

#selectorContainer {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1.5rem;
  margin: 2rem auto;
}

.selectorItem {
  display: flex;
  flex-direction: column;
  align-items: center;
}

/* Wrapper para scroll horizontal de tablas */
.table-wrapper {
  overflow-x: auto;
  width: 100%;
  margin-bottom: 1rem;
  -webkit-overflow-scrolling: touch; /* Scroll suave en iOS */
}

.table-wrapper table {
  margin-bottom: 0;
  min-width: 400px; /* Aumentado para mejor legibilidad */
  width: 100%;
}

/* Responsividad para tablets */
@media (max-width: 1024px) {
  .container {
    gap: 1.5rem;
  }
  
  .digimon-image {
    min-width: 250px;
  }
  
  .digimon-image img {
    width: 240px !important;
    height: 240px !important;
  }
  
  #imagePlaceholder {
    width: 240px;
    height: 240px;
  }
  
  table {
    font-size: 0.9rem;
  }
  
  table th,
  table td {
    padding: 0.4rem;
    font-size: 0.85rem;
  }
}

/* Responsividad para pantallas pequeñas */
@media (max-width: 768px) {
  .container {
    flex-direction: column;
    align-items: center;
    gap: 1rem;
    padding: 0 1rem;
  }
  
  .digimon-image {
    min-width: unset;
    width: 100%;
    max-width: 300px;
  }
  
  .digimon-image img {
    width: 220px !important;
    height: 220px !important;
  }
  
  #imagePlaceholder {
    width: 220px;
    height: 220px;
  }
  
  .digimon-tables {
    width: 100%;
    overflow-x: visible; /* Permitir que el wrapper maneje el scroll */
  }
  
  table {
    font-size: 0.8rem;
  }
  
  table th,
  table td {
    padding: 0.25rem;
    font-size: 0.75rem;
    line-height: 1.2;
  }
  
  /* Hacer que las tablas sean más compactas */
  .table-wrapper table {
    min-width: 350px; /* Balance entre compacto y legible */
  }
  
  nav {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }
  
  nav a {
    text-align: center;
    font-size: 0.9rem;
  }
}

/* Responsividad para pantallas muy pequeñas */
@media (max-width: 480px) {
  #selectorContainer {
    padding: 0 0.5rem;
  }
  
  .digimon-image img {
    width: 180px !important;
    height: 180px !important;
  }
  
  #imagePlaceholder {
    width: 180px;
    height: 180px;
    font-size: 0.85rem;
    padding: 0.5rem;
  }
  
  table {
    font-size: 0.75rem;
  }
  
  table th,
  table td {
    padding: 0.2rem;
    font-size: 0.7rem;
    line-height: 1.1;
  }
  
  /* Tabla compacta pero legible para móviles pequeños */
  .table-wrapper table {
    min-width: 320px;
  }
  
  h1 {
    font-size: 1.5rem;
  }
  
  h2 {
    font-size: 1.2rem;
  }
  
  #disclaimer {
    font-size: 0.8rem;
    padding: 0.8rem;
  }
}

/* NUEVOS ESTILOS PARA TEXTO LARGO EN CELDAS */
@media (max-width: 600px) {
  /* Para textos largos como "Errores de Cuidado" y "Entrenamiento Mínimo" */
  table th,
  table td {
    font-size: 0.7rem;
    line-height: 1.2;
    padding: 0.2rem;
    max-width: 80px; /* Más espacio para legibilidad */
  }
  
  /* Permitir que el texto se ajuste en múltiples líneas */
  table th {
    white-space: normal;
    word-break: break-word;
  }
  
  table td {
    white-space: normal;
    word-break: break-word;
  }
  
  .table-wrapper table {
    min-width: 300px; /* Balance entre compacto y scroll */
  }
}

/* Mejoras generales para mejor UX móvil */
* {
  box-sizing: border-box;
}

body {
  margin: 0;
  padding: 0;
  overflow-x: hidden;
}

main {
  width: 100%;
  max-width: 100vw;
  overflow-x: hidden;
}

/* Asegurar que las tablas no se desborden */
.digimon-tables {
  overflow: hidden;
}

/* Indicador visual de scroll horizontal */
.table-wrapper::after {
  content: "← Desliza para ver más →";
  display: block;
  text-align: center;
  font-size: 0.7rem;
  color: #999;
  padding: 0.5rem;
}

@media (min-width: 769px) {
  .table-wrapper::after {
    display: none;
  }
}
/* Estilos para headers agrupados */
#headersGrupos th {
  background-color: transparent;
  font-weight: bold;
  text-align: center;
  border: 2px solid #333;
  padding: 0.4rem;
  text-align: center;
  border: 1px solid #ddd;
  word-wrap: break-word;
  hyphens: auto;
  overflow-wrap: break-word;
  white-space: normal;
  line-height: 1.3;
  font-size: 0.9rem;
  vertical-align: middle;
}

#headersRequisitos th {
  background-color: transparent;
  font-weight: 600;
  border: 1px solid #ddd;
  padding: 0.4rem;
  text-align: center;
  border: 1px solid #ddd;
  word-wrap: break-word;
  hyphens: auto;
  overflow-wrap: break-word;
  white-space: normal;
  line-height: 1.3;
  font-size: 0.9rem;
  vertical-align: middle;
}

/* Responsive para headers agrupados */
@media (max-width: 768px) {
  #headersGrupos th {
    font-size: 0.8rem;
    padding: 0.4rem 0.2rem;
  }
  
  #headersRequisitos th {
    font-size: 0.7rem;
    padding: 0.25rem;
  }
}
  </style>
</head>
<script src="digimonReqDict.js"></script>
<script src="digimonstattier.js"></script>
<body>
  <header>
    <h1 id="titleMain">Información del Digimon</h1>
    <nav>
      <a href="./index.html">Main Hub</a>
      <a href="./calculadora.html">Digimon Evo Calc</a>
      <a href="./digimonreqs.html">Digimon Reqs</a>
      <a href="./StatRanking.html">Digimon Stat Ranking</a>
	  <a href="./arbolevolutivo.html">Digimon Evolutive Tree</a>
      <a target="_blank" href="https://ndcalcs.github.io/">Carrow Website - General Info</a>
      <a target="_blank" href="https://whiterickle.neocities.org/Road%20To%20Perfect">WhiteRickle Website - Road To Perfect - Guides and Calculator</a>
	  <a target="_blank" href="https://docs.google.com/spreadsheets/d/1WzSCjaje4apqByKV9HyXsLXEao92MoT07VQsNRqeAvI/edit?gid=1769528122#gid=1769528122">Driver Installation Guide</a>
    </nav>
	  <label for="languageSelector">Idioma / Language:</label>
	  <select id="languageSelector">
		<option value="es">Español</option>
		<option value="en">English</option>
	  </select>

  </header>

  <main>
  
<section>
  <div id="selectorContainer">
    <div class="selectorItem">
      <label for="selectTama">Seleccionar Tama:</label>
      <select id="selectTama">
        <option value="">-- Elige un Tama --</option>
      </select>
    </div>

    <div class="selectorItem">
      <label for="selectNivel">Seleccionar Nivel:</label>
      <select id="selectNivel" disabled>
        <option value="">-- Elige un Nivel --</option>
      </select>
    </div>

    <div class="selectorItem">
      <label for="selectDigimon">Seleccionar Digimon:</label>
      <select id="selectDigimon" disabled>
        <option value="">-- Elige un Digimon --</option>
      </select>
    </div>
  </div>
</section>
<section id="disclaimerSection">
	<p id="disclaimer">
		DISCLAIMER: Condiciones recopiladas basados en la experiencia del discord y screenshots. PUEDEN haber errores, en caso de encontrar alguno, contactarme en el discord de Net Driver haciendo ping a @rodrigoalag para revisar el caso.
	</p>
</section>
<section id="explanationsection">
	<p id="explanation">
		Quota/Keypoints: Cada uno da un puntaje de 1. Ocupas un Puntaje de 3 de 4 para evolucionar al digimon. Los Requisitos Obligatorios son obligatorios para evolucionar. Los stats base de Scumon/PlatScumon son un promedio.
	</p>
</section>
<section class="container">
  <div class="top-section">
    <div class="digimon-image">
      <div id="imagePlaceholder">
        <p>Selecciona un Digimon para ver su imagen</p>
      </div>
      <img id="digimonImage" alt="Imagen del Digimon" style="display: none;" />
    </div>

    <div class="digimon-tables">
      <h2 id="subtitle">Datos Generales del Digimon</h2>
      <table id="tablaGenerales">
        <thead>
          <tr>
            <th>ID</th>
            <th>Tama</th>
            <th>Nivel</th>
            <th>Atributo</th>
            <th>Tipo</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>
	<div class="digimon-tables full-width">
	  <h2 id="subtitle3">Stat Base y Evoluciones</h2>
	  <table id="tablaStats">
		<thead>
		  <tr>
			<th>ATK</th>
			<th>DEF</th>
			<th>HP</th>
			<th>Vel</th>
			<th>Digipuntos</th>
			<th>Evoluciona</th>
			<th>Viene</th>
		  </tr>
		</thead>
		<tbody></tbody>
	  </table>
	</div>
  <div class="digimon-tables full-width">
    <h2 id="subtitle2">Datos de requisitos del Digimon</h2>
	<table id="tablaRequisitos">
	  <thead>
		<tr id="headersGrupos">
		  <!-- Los headers agrupados se generarán dinámicamente -->
		</tr>
		<tr id="headersRequisitos">
		  <!-- Los headers individuales se generarán dinámicamente -->
		</tr>
	  </thead>
	  <tbody></tbody>
	</table>
  </div>
</section>
  </main>
<script>
// CONFIGURACIÓN DE EXCEPCIONES ESPECIALES
const specialDigimonConfig = {
  "SkullGreymon": {
    gruposColumnas: {
      "No se considera en el puntaje": ["Peso"],
      "Requisitos Obligatorios": ["% Entrenamiento", "Errores Minimos", "Combates Minimos", "Vinculo al momento de evolucionar", "Program o Comida"]
    },
    procesarCampos: function(digimon) {
      const procesado = {...digimon};
      if (digimon.Program && digimon.Comida) {
        procesado["Program o Comida"] = "Death o Carne X";
        delete procesado.Program;
        delete procesado.Comida;
      }
      return procesado;
    }
  },
  "Bakemon LT": {
    gruposColumnas: {
      "No se considera en el puntaje": ["Peso"],
      "Evolucion por muerte inducida": ["Muerte inducida sin Carne X o Program (30% de salir)", "Program / Comida (Asegura evolucion)"]
    },
    procesarCampos: function(digimon) {
      const procesado = {...digimon};
      // Combinar Program y Comida
      if (digimon.Program && digimon.Comida) {
        procesado["Program / Comida (Asegura evolucion)"] = "Death / Carne X";
        delete procesado.Program;
        delete procesado.Comida;
      }
      // Agregar campo de muerte inducida
      procesado["Muerte inducida sin Carne X o Program (30% de salir)"] = "Si";
      return procesado;
    }
  },
  "PlatinumScumon": {
    gruposColumnas: {
      "No se considera en el puntaje": ["Peso"],
      "Requisitos Obligatorios": ["Comida"]
    }
  },
  "GoldNumemon": {
    gruposColumnas: {
      "No se considera en el puntaje": ["Peso"],
      "Requisitos Obligatorios": ["Comida"]
    }
  },
  "Geremon": {
    gruposColumnas: {
      "No se considera en el puntaje": ["Peso"],
      "Requisitos Obligatorios": ["Program"]
    }
  },
  "Scumon": {
    gruposColumnas: {
      "No se considera en el puntaje": ["Peso"],
      "Requisitos Obligatorios": ["Comida"]
    }
  },
   "KaratsukiNumemon": {
    gruposColumnas: {
      "No se considera en el puntaje": ["Peso"],
      "Requisitos Obligatorios": ["Comida"]
    }
  },
   "Numemon": {
    gruposColumnas: {
      "No se considera en el puntaje": ["Peso"]
	} 
  },
   "Pillomon": {
    gruposColumnas: {
      "No se considera en el puntaje": ["Peso"],
      "Requisitos Obligatorios": ["% Entrenamiento", "EntrenamientoHecho"]
	} 
  },
   "Burpmon": {
    gruposColumnas: {
      "Requisitos Obligatorios": ["Peso"]
	} 
  },
   "GreatKingScumon": {
    gruposColumnas: {
	  "No se considera en el puntaje": ["Peso", "Error Maximo"],
      "Requisitos Obligatorios": ["% Entrenamiento", "Menos de 15 entrenamientos?"]
	} 
  },
   "Kokuwamon": {
    gruposColumnas: {
	  "No se considera en el puntaje": ["Peso", "Error Maximo"],
	  "Quota/Key Points": ["EntrenamientoHecho", "Stat Superior"]
	} 
  },
   "Agumon": {
    gruposColumnas: {
	  "No se considera en el puntaje": ["Peso", "Error Maximo"],
	  "Quota/Key Points": ["EntrenamientoHecho", "Stat Superior", "Stat Superior 2"]
	} 
  },
   "Agumon (Black)": {
    gruposColumnas: {
	  "No se considera en el puntaje": ["Peso", "Error Maximo"],
	  "Quota/Key Points": ["EntrenamientoHecho", "Stat Superior", "Stat Superior 2"],
	  "Requisitos Obligatorios": ["Program"]
	} 
  },
   "Yuki Agumon": {
    gruposColumnas: {
	  "No se considera en el puntaje": ["Peso", "Error Maximo"],
	  "Quota/Key Points": ["EntrenamientoHecho", "Stat Superior", "Stat Superior 2"],
	  "Requisitos Obligatorios": ["Program"]
	} 
  },
    "Agumon (2006)": {
    gruposColumnas: {
	  "No se considera en el puntaje": ["Peso", "Error Maximo"],
	  "Quota/Key Points": ["EntrenamientoHecho", "Stat Superior", "Stat Superior 2"],
	  "Requisitos Obligatorios": ["Program", "2Ciclos"]
	} 
  },
"V-Dramon": {
  gruposColumnas: {
    "Quota/Key Points": ["Peso", "% Entrenamiento", "Bonus WinRate"],
    "Requisitos Obligatorios": ["Error Maximo", "WinRate", "Combates Minimos", "Vinculo Minimo alcanzado"]
  } 
}, 

"V-Dramon (Black)": {
  gruposColumnas: {
    "Quota/Key Points": ["Peso", "% Entrenamiento", "Bonus Batallas"],
    "Requisitos Obligatorios": ["Error Maximo", "WinRate", "Combates Minimos", "Vinculo Minimo alcanzado", "Program"]
  } 
}, 

"Aero V-dramon": {
  gruposColumnas: {
    "Quota/Key Points": ["Peso", "% Entrenamiento", "Digimon Bonus"],
    "Requisitos Obligatorios": ["Error Maximo", "WinRate", "Combates Minimos", "Vinculo Minimo alcanzado"]
  } 
}, 

"Monzaemon": {
  gruposColumnas: {
    "Quota/Key Points": ["Peso", "% Entrenamiento", "Digimon Bonus"],
    "Requisitos Obligatorios": ["Error Maximo", "WinRate", "Combates Minimos"]
  } 
}, 

"Black King Numemon": {
  gruposColumnas: {
    "Quota/Key Points": ["Peso", "% Entrenamiento", "Digimon Bonus"],
    "Requisitos Obligatorios": ["Error Maximo", "WinRate", "Combates Minimos", "Program"]
  } 
}, 

"Etemon": {
  gruposColumnas: {
    "Quota/Key Points": ["Peso", "% Entrenamiento", "Digimon Bonus"],
    "Requisitos Obligatorios": ["Error Maximo", "WinRate", "Combates Minimos"]
  } 
}, 

"Aero V-dramon (Black)": {
  gruposColumnas: {
    "Quota/Key Points": ["Peso", "% Entrenamiento", "Digimon Bonus"],
    "Requisitos Obligatorios": ["Error Maximo", "WinRate", "Combates Minimos", "Vinculo Minimo alcanzado", "Program"]
  } 
}, 

"Insekimon High Tier": {
  gruposColumnas: {
    "Quota/Key Points": ["Peso", "% Entrenamiento"],
    "Requisitos Obligatorios": ["Error Maximo", "WinRate", "Combates Minimos", "Driver Equipado"]
  } 
}, 

"Fantomon": {
  gruposColumnas: {
    "Quota/Key Points": ["Peso", "% Entrenamiento", "Digimon Bonus"],
    "Requisitos Obligatorios": ["Error Maximo", "WinRate", "Combates Minimos"]
  } 
},
"Nanimon":  {
  gruposColumnas: {
    "No se considera en el puntaje": ["Peso"],
    "Requisitos Obligatorios": ["Vinculo al momento de evolucionar"]
  }
  },
"BomberNanimon":  {
  gruposColumnas: {
    "No se considera en el puntaje": ["Peso"],
    "Requisitos Obligatorios": ["Xross"]
  }
  },
"Mushmon":  {
  gruposColumnas: {
    "No se considera en el puntaje": ["Peso"],
    "Requisitos Obligatorios": ["Program"]
  }
  },
"PrinceMamemon":  {
  gruposColumnas: {
    "No se considera en el puntaje": ["Peso", "Error Maximo"],
    "Requisitos Obligatorios": ["% Entrenamiento", "Combates Minimos", "WinRate", "Program"]
  }
  },  
"Daipenmon":  {
  gruposColumnas: {
    "No se considera en el puntaje": ["Peso", "Error Maximo"],
    "Requisitos Obligatorios": ["% Entrenamiento", "Combates Minimos", "WinRate", "Xross"]
  }
  },  
"Mugendramon":  {
  gruposColumnas: {
    "No se considera en el puntaje": ["Peso", "Error Maximo"],
    "Requisitos Obligatorios": ["% Entrenamiento", "Combates Minimos", "WinRate", "Xross"]
  }
  },  
"MetalEtemon":  {
  gruposColumnas: {
    "No se considera en el puntaje": ["Peso", "Error Maximo"],
    "Requisitos Obligatorios": ["% Entrenamiento", "Combates Minimos", "WinRate", "Program"]
  }
  },  
"PlatinumNumemon":  {
  gruposColumnas: {
    "No se considera en el puntaje": ["Peso", "Error Maximo"],
    "Requisitos Obligatorios": ["% Entrenamiento", "Combates Minimos", "WinRate", "Xross"]
  }
  }, 
"Digitamamon": {
  gruposColumnas: {
    "Quota/Key Points": ["Peso", "% Entrenamiento", "Digimon Bonus"],
    "Requisitos Obligatorios": ["Error Maximo", "WinRate", "Combates Minimos"]
  } 
},  
"Tyranomon": {
  gruposColumnas: {
    "Quota/Key Points": ["Peso", "% Entrenamiento", "Stat Superior", "Error Maximo"],
    "Requisitos Obligatorios": ["WinRate", "Combates Minimos"]
  } 
},  
};
// Configuración por defecto (la original)
const gruposColumnasDefault = {
  "Quota/Key Points": ["Peso", "Error Maximo", "% Entrenamiento", "Bonus Batallas", "Digimon Bonus", "Bonus WinRate", "Bonus Errores", "Bonus Comida", "Bonus Vinculo al momento de evolucionar"],
  "Requisitos Obligatorios": ["WinRate", "Combates Minimos", "Vinculo Minimo alcanzado","Vinculo al momento de evolucionar","Menos de 15 entrenamientos?", "Program", "Stat Superior", "Stat Superior 2", "Xross", "Driver Equipado", "2Ciclos", "Alcanzo vinculo negativo?", "Comida", "EntrenamientoHecho", "Victorias"]
};

const specialProgramCases = { 
  "Icemon": { 
    "Yuki Agumon": "Ore", 
    "Gotsumon": "Frost" 
  }
};
const specialxrossCases = {
    "Mugendramon": {
        "Megadramon": "Metal Greymon (Virus) Driver + Metal Tyranomon Driver + MetalMamemon Driver + Andromon Driver",
		"Gigadramon": "Metal Greymon (Virus) Driver + Metal Tyranomon Driver + MetalMamemon Driver + Andromon Driver",
        "Metal Greymon (Virus)": "Megadramon Driver + Metal Tyranomon Driver + MetalMamemon Driver + Andromon Driver",
		"Metal Tyranomon": "Metal Greymon (Virus) Driver + Megadramon Driver + MetalMamemon Driver + Andromon Driver",
		"MetalMamemon": "Metal Greymon (Virus) Driver + Metal Tyranomon Driver + Megadramon Driver + Andromon Driver",
		"Andromon": "Metal Greymon (Virus) Driver + Metal Tyranomon Driver + MetalMamemon Driver + Megadramon Driver"
},
	"Daipenmon": {
		"Blizzarmon":["Ice Spirit H"],
		"Polarbearmon": ["Ice Spirit B + Ice Spirit H","Ice Spirit A"]
	}
};
const specialEntrenamientoCases = {
    "Chackmon": {
        "Icemon": 100,
        "Yukidarumon": 100,
		"Yuki Agumon": 80
},
    "Blizzarmon": {
        "Icemon": 80,
        "Yukidarumon": 80,
		"Chackmon":80,
		"Polarbearmon": 100
	}
};
const specialfoodcases = {
    "Icemon": ["Verdura Congelada", "Hongo Congelado"]
};

  const dict = digimonReqDict;
  const generales = ["ID", "Tama", "Nivel", "Atributo", "Tipo"];

  const nivelAEtapa = {
    1: "Baby I",
    2: "Baby II", 
    3: "Child",
    4: "Adult",
    5: "Perfect",
	6: "Ultimate"
  };

  const selectTama = document.getElementById("selectTama");
  const selectNivel = document.getElementById("selectNivel");
  const selectDigimon = document.getElementById("selectDigimon");

  const tablaGenerales = document.querySelector("#tablaGenerales tbody");
  const tablaHeaders = document.getElementById("headersRequisitos");
  const tablaRequisitos = document.querySelector("#tablaRequisitos tbody");
  const digimonImage = document.getElementById("digimonImage");
  const imagePlaceholder = document.getElementById("imagePlaceholder");

  const uniqueValues = (array) => [...new Set(array)];
	 const traducciones = {
	  es: {
	    titleMain: "Información del Digimon",
		subtitle: "Datos Generales del Digimon",
		subtitle2: "Datos de requisitos del Digimon", 
		disclaimer: "DISCLAIMER: Condiciones recopiladas basados en la experiencia del discord y screenshots. PUEDEN haber errores, en caso de encontrar alguno, contactarme en el discord de Net Driver haciendo ping a @rodrigoalag para revisar el caso.",
		explanation: "Quota/Keypoints: Cada uno da un puntaje de 1. Ocupas un Puntaje de 3 de 4 para evolucionar al digimon. Los Requisitos Obligatorios son obligatorios para evolucionar. Los stats base de Scumon/PlatScumon y GreatKingScumon son un promedio de todos los childs, estos ya tienen los heredados contrario a los demás digis.",
		Tama: "Tama",
		Nivel: "Nivel",
		Atributo: "Atributo",
		Tipo: "Tipo",
		ID: "ID",
		"selectTama": "Seleccionar Tama:",
		"selectNivel": "Seleccionar Nivel:",
		"selectDigimon": "Seleccionar Digimon:",
		"selectTamaDefault": "-- Elige un Tama --",
		"selectNivelDefault": "-- Elige un Nivel --",
		"selectDigimonDefault": "-- Elige un Digimon --",
	    "Bellota Dorada": "Bellota Dorada",
		"Verdura Congelada": "Verdura Congelada como última comida antes de la evolución",
		"Hongo Congelado": "Hongo Congelado como última comida antes de al evolución",
		"Ninguno":"Ninguno",
		"Si":"Si",
		"No":"No",
		"No Muerto": "No Muerto",
		"Death o Carne X": "Death o Carne X",
		"Death / Carne X": "Death / Carne X",
		"Nuez Magica": "Nuez Magica",
		"Balanceado":"Balanceado",
		"Compuesto": "Compuesto", 
		"Dinosaurio": "Dinosaurio",
		"Vacuna": "Vacuna",
		"Maquina": "Maquina",
		"Hielo": "Hielo",
		"Mutante": "Mutante",
		"Tierra": "Tierra",
		"5 Caca": "5 Caca",
		"5 Sardinas": "5 Sardinas",
		"Chatarra": "Chatarra",
		"Starmon o ShootingStarmon Driver": "Starmon o ShootingStarmon Driver",
		"SuperStarmon y DarkSuperStarmon Driver": "SuperStarmon y DarkSuperStarmon Driver",
		"3 Monzaemon Driver en WaruMonzaemon o 3 WaruMonzaemon Driver en Monzaemon": "3 Monzaemon Driver en WaruMonzaemon o 3 WaruMonzaemon Driver en Monzaemon",
		"Vel":"Vel",
		    campos: {
      "Peso": "Peso",
      "Error Maximo": "Errores de Cuido Maximos",
	  "Errores Minimos": "Errores Mínimos",
      "EntrenamientoHecho": "Entrenamiento Hecho",
      "Stat Superior": "Stat Superior",
      "Stat Superior 2": "Stat Superior 2",
      "2Ciclos": "Haber Conseguido 2 perfects en las ultimas dos generaciones / Haber tenido Agumon 06 antes",
      "Program": "Program",
	  "Program o Comida": "Program o Comida",
	  "Program / Comida (Asegura evolucion)": "Program / Comida (Asegura evolucion)",
	  "Muerte inducida sin Carne X o Program (30% de salir)": "Muerte inducida sin Carne X o Program (30% de salir)",
      "% de Entrenamiento": "% Entrenamiento",
      "Digimon Bonus": "Bonus Digimon",
      "Vinculo Minimo alcanzado": "Vínculo Alcanzado",
	  "Menos de 15 entrenamientos?": "Menos de 15 entrenamientos?",
      "Win Rate": "Win Rate",
      "Combates Minimos": "Combates Mínimos",
	  "% Entrenamiento": "% Entrenamiento Minimo",
	  "Bonus Batallas": "Bonus Batallas",
	  "Comida" : "Comida",
	  "Victorias": "Victorias",
	  "Driver Equipado": "Driver Equipado",
	  "Xross":"Xross/Install",
	  "Bonus Vinculo al momento de evolucionar":"Bonus Vinculo al momento de evolucionar",
	  "Vinculo al momento de evolucionar": "Vínculo al momento de evolucionar",
	  "Alcanzo vinculo negativo?": "Alcanzo vinculo negativo?",
    },
	    grupos: {
      "Quota/Key Points": "Quota/Key Points",
      "Requisitos Obligatorios": "Requisitos Obligatorios",
	  "No se considera en el puntaje": "No se considera en el puntaje",
	  "Evolucion por muerte inducida": "Evolucion por muerte inducida"
    },
	  subtitle3: "Stat Base y Evoluciones",
	  ATK: "ATK",
	  DEF: "DEF", 
	  HP: "HP",
	  Vel: "Vel",
	  Digipuntos: "Digipuntos",
	  Evoluciona: "Evoluciona a",
	  Viene: "Viene de"
	  },
	  en: {
	  	titleMain: "Digimon Information",
		subtitle: "General Digimon Data",
		subtitle2: "Digimon Requirements Data",
		disclaimer:"DISCLAIMER: Conditions based on the user experience of the discord and screenshots. There can be errors or mistakes, in case of finding one, please contact me at Net Driver discord by pinging @rodrigoalag to check the case.",		
		explanation: "Quota/Keypoints: Each one gives 1 point on the total point. You need 3 out of 4 points to evolve to a Digimon. Mandatory Requirements are mandatory to evolve. The base stats from Scumon/PlatScumon and GreatKingScumon are an average. Contrary to the rest of Digimon, Scumon/PlatScumon and GreatKingScumon already have their hereditary (NATO) stats added in the avg.", 
		Tama: "Tama",
		Nivel: "Level",
		Atributo: "Attribute",
		Tipo: "Type",
		ID: "ID",
		"selectTama": "Select Tama:",
		"selectNivel": "Select Level:",
		"selectDigimon": "Select Digimon:",
		"selectTamaDefault": "-- Choose a Size --",
		"selectNivelDefault": "-- Choose a Level --",
		"selectDigimonDefault": "-- Choose a Digimon --",
	    "Bellota Dorada": "Golden Acorn",
		"Verdura Congelada": "Frozen Vegetable as last food eaten before evolving.",
		"Hongo Congelado": "Frozen Mushroom as last food eaten before evolving.",
		"Ninguno":"None",
		"Si":"Yes",
		"No":"No",
		"No Muerto": "Undead",
		"Death o Carne X": "Death or X Meat",
		"Death / Carne X": "Death / X Meat",
		"Nuez Magica": "Magical Nut",
		"Balanceado":"Balanced",	
		"Compuesto": "Composite", 
		"Dinosaurio": "Dinosaur",
		"Vacuna": "Vaccine",
		"Maquina": "Machine",
		"Hielo": "Ice",
		"Mutante": "Mutant",
		"Tierra": "Earth",		
		"5 Caca": "5 Poop",
		"5 Sardinas": "5 DigiSardine",
		"Chatarra": "Metal Scrap",
		"Starmon o ShootingStarmon Driver": "Starmon or ShootingStarmon Driver",
		"SuperStarmon y DarkSuperStarmon Driver": "SuperStarmon and DarkSuperStarmon Driver",
		"3 Monzaemon Driver en WaruMonzaemon o 3 WaruMonzaemon Driver en Monzaemon": "3 Monzaemon Driver in WaruMonzaemon or 3 WaruMonzaemon Driver in Monzaemon",
		"Vel":"SPD",
		    campos: {
      "Peso": "Weight",
      "Error Maximo": "Max Care Mistakes",
	  "Errores Minimos": "Minimum Errors",
      "EntrenamientoHecho": "Training Done",
      "Stat Superior": "Highest Stat",
      "Stat Superior 2": "Highest Stat 2",
      "2Ciclos": "Have obtain 2 perfects on last two generations / Have obtain Agumon 06",
      "Program": "Program",
	  "Program o Comida": "Program or Food",
	  "Program / Comida (Asegura evolucion)": "Program / Food (Ensures evolution)",
	  "Muerte inducida sin Carne X o Program (30% de salir)": "Induced death without X Meat or Program (30% chance)",
      "% de Entrenamiento": "% Training",
      "Digimon Bonus": "Digimon Bonus",
      "Vinculo Minimo alcanzado": "Bond Reached",
	  "Menos de 15 entrenamientos?": "Less than 15 trainings?",
      "Combates Minimos": "Minimum Battles",
	  "% Entrenamiento": "Training Cap %",
	  "Bonus Batallas": "Battle Bonus",
	  "Comida" : "Food",
	  "Victorias": "Battle Victories",
	  "Driver Equipado": "Driver Equipped",
	  "Xross":"Xross/Install",
	  "Bonus Vinculo al momento de evolucionar":"Bond at evolution",
	  "Vinculo al momento de evolucionar": "Bond at evolution",
	  "Alcanzo vinculo negativo?": "Reached negative bond?",
    },
	    grupos: {
      "Quota/Key Points": "Quota/Key Points", 
      "Requisitos Obligatorios": "Mandatory Requirements",
	  "No se considera en el puntaje": "Not considered in scoring",
	  "Evolucion por muerte inducida": "Evolution by induced death"
    },
	  subtitle3: "Base Stats and Evolutions", 
	  ATK: "ATK",
	  DEF: "DEF",
	  HP: "HP", 
	  Vel: "SPD",
	  Digipuntos: "Digipoints",
	  Evoluciona: "Evolves To",
	  Viene: "Comes From"
	  }
	};

let currentLanguage = "es";

function t(key) {
  return traducciones[currentLanguage][key] || key;
}

// Función para obtener la configuración de columnas para un digimon específico
function obtenerGruposColumnas(nombreDigimon) {
  if (specialDigimonConfig[nombreDigimon] && specialDigimonConfig[nombreDigimon].gruposColumnas) {
    return specialDigimonConfig[nombreDigimon].gruposColumnas;
  }
  return gruposColumnasDefault;
}

// Función para procesar los datos del digimon si tiene configuración especial
function procesarDatosDigimon(nombreDigimon, datosOriginales) {
  if (specialDigimonConfig[nombreDigimon] && specialDigimonConfig[nombreDigimon].procesarCampos) {
    return specialDigimonConfig[nombreDigimon].procesarCampos(datosOriginales);
  }
  return datosOriginales;
}

// Función para generar múltiples variaciones del nombre de archivo
function generarVariacionesNombre(nombre) {
  const nombreLimpio = nombre.toLowerCase().replace(/[^a-z0-9]/gi, "");
  const nombreEspacios = nombre.toLowerCase().replace(/[^a-z0-9\s]/gi, "").replace(/\s+/g, "");
  const nombreGuiones = nombre.toLowerCase().replace(/[^a-z0-9\s]/gi, "").replace(/\s+/g, "-");
  const nombreOriginal = nombre.replace(/[^a-zA-Z0-9\s]/gi, "").replace(/\s+/g, "");
  
  // Variaciones para probar
  const variaciones = [
    nombreLimpio,                    // darktyranomon (original)
    nombreEspacios,                  // darktyranomon (sin espacios)
    nombreGuiones,                   // dark-tyranomon (con guiones)
    nombreOriginal.toLowerCase(),    // darktyranomon (preservando estructura)
    nombreOriginal,                  // DarkTyranomon (con mayúsculas)
    nombre.replace(/[^a-zA-Z0-9]/gi, "").toLowerCase(), // sin símbolos especiales
  ];
  
  // Eliminar duplicados
  return [...new Set(variaciones)];
}

// Función para intentar cargar imagen con múltiples variaciones
function cargarImagenConVariaciones(nombre, elementoImg, callback) {
  const variaciones = generarVariacionesNombre(nombre);
  
  console.log(`Intentando cargar imagen para: ${nombre}`);
  console.log(`Variaciones a probar:`, variaciones);
  
  let indiceActual = 0;
  
  const intentarSiguiente = () => {
    if (indiceActual >= variaciones.length) {
      // Si fallan todas las variaciones, intentar con placeholder.png
      console.log(`❌ No se encontró imagen específica para ${nombre}. Intentando placeholder.png...`);
      
      const imgPlaceholder = new Image();
      imgPlaceholder.onload = function() {
        console.log(`✅ Usando placeholder.png para ${nombre}`);
        elementoImg.src = 'img/placeholder.png';
        elementoImg.style.display = 'block';
        imagePlaceholder.style.display = 'none';
        if (callback) callback(true, 'img/placeholder.png');
      };
      imgPlaceholder.onerror = function() {
        console.log(`❌ No se encontró placeholder.png. Usando placeholder de texto.`);
        elementoImg.style.display = 'none';
        imagePlaceholder.style.display = 'flex';
        if (callback) callback(false);
      };
      imgPlaceholder.src = 'img/placeholder.png';
      return;
    }
    
    const variacionActual = variaciones[indiceActual];
    const ruta = `img/${variacionActual}.png`;
    
    console.log(`Probando: ${ruta}`);
    
    const imgTest = new Image();
    imgTest.onload = function() {
      console.log(`✅ Imagen encontrada: ${ruta}`);
      elementoImg.src = ruta;
      elementoImg.style.display = 'block';
      imagePlaceholder.style.display = 'none';
      if (callback) callback(true, ruta);
    };
    imgTest.onerror = function() {
      console.log(`❌ No encontrada: ${ruta}`);
      indiceActual++;
      intentarSiguiente();
    };
    imgTest.src = ruta;
  };
  
  intentarSiguiente();
}

  // Llenar Tama inicial
  const allTamas = uniqueValues(Object.values(dict).map(d => d.Tama));
  allTamas.forEach(tama => {
    const opt = document.createElement("option");
    opt.value = tama;
    opt.textContent = tama;
    selectTama.appendChild(opt);
  });

  selectTama.addEventListener("change", () => {
    selectNivel.innerHTML = '<option value="">-- Elige un Nivel --</option>';
    selectDigimon.innerHTML = '<option value="">-- Elige un Digimon --</option>';
    selectNivel.disabled = true;
    selectDigimon.disabled = true;
    
    // Mostrar placeholder cuando se cambie Tama
    digimonImage.style.display = 'none';
    imagePlaceholder.style.display = 'flex';

    const tamSelected = selectTama.value;
    if (!tamSelected) return;

    const niveles = uniqueValues(Object.values(dict)
      .filter(d => d.Tama === tamSelected)
      .map(d => d.Nivel))
      .sort((a, b) => a - b);

    niveles.forEach(nivel => {
      const opt = document.createElement("option");
      opt.value = nivel;
      opt.textContent = nivelAEtapa[nivel] || `Nivel ${nivel}`;
      selectNivel.appendChild(opt);
    });

    selectNivel.disabled = false;
  });

  selectNivel.addEventListener("change", () => {
    selectDigimon.innerHTML = '<option value="">-- Elige un Digimon --</option>';
    selectDigimon.disabled = true;
    
    // Mostrar placeholder cuando se cambie Nivel
    digimonImage.style.display = 'none';
    imagePlaceholder.style.display = 'flex';

    const tamSelected = selectTama.value;
    const nivelSelected = parseInt(selectNivel.value);
    if (!tamSelected || isNaN(nivelSelected)) return;

    const digimons = Object.entries(dict)
      .filter(([_, d]) => d.Tama === tamSelected && d.Nivel === nivelSelected);

    digimons.forEach(([nombre]) => {
      const opt = document.createElement("option");
      opt.value = nombre;
      opt.textContent = nombre;
      selectDigimon.appendChild(opt);
    });

    selectDigimon.disabled = false;
  });

  // Event listener mejorado para selectDigimon
  selectDigimon.addEventListener("change", () => {
    const nombre = selectDigimon.value;
    if (!nombre || !dict[nombre]) {
      // Si no hay selección, mostrar placeholder y limpiar tablas
      digimonImage.style.display = 'none';
      imagePlaceholder.style.display = 'flex';
      tablaGenerales.innerHTML = "";
      tablaHeaders.innerHTML = "";
      tablaRequisitos.innerHTML = "";
	  // Restaurar título por defecto cuando no hay selección
      document.getElementById("subtitle").textContent = t("subtitle");
      return;
    }
	
	// Actualizar el título con el nombre del Digimon
	if (currentLanguage === 'es') {
	  document.getElementById("subtitle").textContent = `Datos Generales de ${nombre}`;
	} else {
	  document.getElementById("subtitle").textContent = `${nombre} General Data`;
	}

	// Procesar datos del digimon si tiene configuración especial
    const datosOriginales = dict[nombre];
    const digimon = procesarDatosDigimon(nombre, datosOriginales);

    // Cargar imagen solo después de seleccionar Digimon
    console.log(`Digimon seleccionado: ${nombre}`);
    cargarImagenConVariaciones(nombre, digimonImage, (exito, rutaUsada) => {
      if (exito) {
        console.log(`Imagen cargada exitosamente desde: ${rutaUsada}`);
      } else {
        console.log(`No se pudo cargar imagen para: ${nombre}`);
      }
    });

    // Actualizar tabla de datos generales
    tablaGenerales.innerHTML = "";
    const filaGen = document.createElement("tr");
    generales.forEach(campo => {
      const td = document.createElement("td");
      let valorOriginal = digimon[campo] ?? "-";
      if (campo === "Nivel") {
        valorOriginal = nivelAEtapa[valorOriginal] || valorOriginal;
      }
      td.innerHTML = traducirValor(campo, valorOriginal);
      filaGen.appendChild(td);
    });
    tablaGenerales.appendChild(filaGen);
	// Actualizar tabla de stats
	const tablaStats = document.querySelector("#tablaStats tbody");
	tablaStats.innerHTML = "";

	if (digimonstattier[nombre]) {
	  const statsDigimon = digimonstattier[nombre];
	  const filaStats = document.createElement("tr");
	  
	  // Campos básicos (ATK, DEF, HP, Vel, Digipuntos)
	  ["ATK", "DEF", "HP", "Vel", "Digipuntos"].forEach(campo => {
		const td = document.createElement("td");
		td.textContent = statsDigimon[campo] ?? "-";
		filaStats.appendChild(td);
	  });
	  
	  // Campo Evoluciona (como lista)
	  const tdEvoluciona = document.createElement("td");
	  if (statsDigimon.Evoluciona && statsDigimon.Evoluciona.length > 0) {
		const lista = statsDigimon.Evoluciona.map(evo => `• ${evo}`).join('<br>');
		tdEvoluciona.innerHTML = lista;
	  } else {
		tdEvoluciona.textContent = "-";
	  }
	  filaStats.appendChild(tdEvoluciona);
	  
// Campo Viene (como lista)
const tdViene = document.createElement("td");
if (nombre === "Burpmon") {
  tdViene.textContent = "Todos los Digimon";
} else if (statsDigimon.Viene && statsDigimon.Viene.length > 0) {
  const lista = statsDigimon.Viene.map(viene => `• ${viene}`).join('<br>');
  tdViene.innerHTML = lista;
} else {
  tdViene.textContent = "-";
}
filaStats.appendChild(tdViene);

tablaStats.appendChild(filaStats);
} else {
  // Si no hay datos de stats, mostrar fila vacía
  const filaVacia = document.createElement("tr");
  for (let i = 0; i < 7; i++) {
    const td = document.createElement("td");
    td.textContent = "-";
    filaVacia.appendChild(td);
  }
  tablaStats.appendChild(filaVacia);
}

// Actualizar tabla de requisitos con configuración especial
const headersGrupos = document.getElementById("headersGrupos");
const tablaHeaders = document.getElementById("headersRequisitos");
const tablaRequisitos = document.querySelector("#tablaRequisitos tbody");

headersGrupos.innerHTML = "";
tablaHeaders.innerHTML = "";
tablaRequisitos.innerHTML = "";

const filaReq = document.createElement("tr");
const camposDisponibles = Object.keys(digimon).filter(campo => !generales.includes(campo));

// Obtener la configuración de columnas para este digimon específico
const gruposColumnas = obtenerGruposColumnas(nombre);

// Crear headers agrupados y individuales
Object.entries(gruposColumnas).forEach(([nombreGrupo, camposGrupo]) => {
  const camposEncontrados = camposGrupo.filter(campo => camposDisponibles.includes(campo));
  
  if (camposEncontrados.length > 0) {
    // Header agrupado
    const thGrupo = document.createElement("th");
    thGrupo.setAttribute("colspan", camposEncontrados.length);
    thGrupo.textContent = traducciones[currentLanguage]?.grupos?.[nombreGrupo] || nombreGrupo;
    headersGrupos.appendChild(thGrupo);
    
    // Headers individuales
    camposEncontrados.forEach(campo => {
      const th = document.createElement("th");
      th.setAttribute("data-orig", campo);
      th.textContent = traducirCampo(campo);
      tablaHeaders.appendChild(th);
      
      // Celda de datos
      const td = document.createElement("td");
      const valorOriginal = digimon[campo];
      td.innerHTML = traducirValor(campo, valorOriginal);
      filaReq.appendChild(td);
    });
  }
});

tablaRequisitos.appendChild(filaReq);
  });

function actualizarTextosUI() {
  // Actualizar títulos principales
  document.getElementById("titleMain").textContent = t("titleMain");
  document.getElementById("subtitle2").textContent = t("subtitle2");
  document.getElementById("disclaimer").textContent = t("disclaimer");
  document.getElementById("explanation").textContent = t("explanation");
  
  // Actualizar el subtitle dinámicamente si hay un Digimon seleccionado
  const nombreDigimon = selectDigimon.value;
  if (nombreDigimon && dict[nombreDigimon]) {
    if (currentLanguage === 'es') {
      document.getElementById("subtitle").textContent = `Datos Generales de ${nombreDigimon}`;
    } else {
      document.getElementById("subtitle").textContent = `${nombreDigimon} General Data`;
    }
  } else {
    document.getElementById("subtitle").textContent = t("subtitle");
  }

  // Actualizar labels de selectores
  document.querySelector('label[for="selectTama"]').textContent = t("selectTama");
  document.querySelector('label[for="selectNivel"]').textContent = t("selectNivel");
  document.querySelector('label[for="selectDigimon"]').textContent = t("selectDigimon");

  // Actualizar opciones por defecto de selectores
  selectTama.options[0].textContent = t("selectTamaDefault");
  selectNivel.options[0].textContent = t("selectNivelDefault");
  selectDigimon.options[0].textContent = t("selectDigimonDefault");

  // Actualiza encabezados de tabla generales
  const headersGen = document.querySelectorAll("#tablaGenerales thead th");
  const claves = ["ID", "Tama", "Nivel", "Atributo", "Tipo"];
  headersGen.forEach((th, idx) => th.textContent = t(claves[idx]));

  // Vuelve a traducir cabeceras de requisitos si existen
  const headersReq = document.querySelectorAll("#headersRequisitos th");
  headersReq.forEach(th => {
    const original = th.getAttribute("data-orig") || th.textContent;
    th.textContent = traducirCampo(original);
    th.setAttribute("data-orig", original);
  });
// Dentro de actualizarTextosUI(), después de re-traducir headers de requisitos:
const headersGrupos = document.querySelectorAll("#headersGrupos th");
headersGrupos.forEach(th => {
  const colspan = th.getAttribute("colspan");
  const textoOriginal = th.textContent;
  
  // Buscar en grupos de traducciones
  Object.entries(traducciones[currentLanguage]?.grupos || {}).forEach(([key, value]) => {
    if (th.textContent.includes(key.split('/')[0]) || th.textContent === key) {
      th.textContent = value;
    }
  });
});
  // Re-traducir los valores de tablaGenerales
  const filaGen = tablaGenerales.querySelector("tr");
  if (filaGen && selectDigimon.value && dict[selectDigimon.value]) {
    const digimon = dict[selectDigimon.value];
    [...filaGen.children].forEach((td, idx) => {
      const campo = generales[idx];
      td.textContent = traducirValor(campo, digimon[campo]);
    });
  }

  // Re-traducir los valores de tablaRequisitos
  const filaReq = tablaRequisitos.querySelector("tr");
  if (filaReq && selectDigimon.value && dict[selectDigimon.value]) {
	const nombreDigimon = selectDigimon.value;
    const datosOriginales = dict[nombreDigimon];
    const digimon = procesarDatosDigimon(nombreDigimon, datosOriginales);
    let i = 0;
    Object.keys(digimon).forEach(campo => {
      if (!generales.includes(campo)) {
        const td = filaReq.children[i];
		if (td) {
          td.innerHTML = traducirValor(campo, digimon[campo]);
        }
        i++;
      }
    });
  }
	// Actualizar título de stats
	document.getElementById("subtitle3").textContent = t("subtitle3");

	// Actualizar headers de tabla stats
	const headersStats = document.querySelectorAll("#tablaStats thead th");
	const clavesStats = ["ATK", "DEF", "HP", "Vel", "Digipuntos", "Evoluciona", "Viene"];
	headersStats.forEach((th, idx) => th.textContent = t(clavesStats[idx]));
}

languageSelector.addEventListener("change", () => {
  currentLanguage = languageSelector.value;
  actualizarTextosUI();
  
  // Agregar estas líneas para forzar actualización de la tabla
  if (selectDigimon.value) {
    selectDigimon.dispatchEvent(new Event('change'));
  }
});

document.addEventListener("DOMContentLoaded", () => {
  actualizarTextosUI();
});

function traducirCampo(campo) {
  return traducciones[currentLanguage]?.campos?.[campo] || campo;
}

function traducirValor(campo, valor) {
  if (campo === "Nivel" && nivelAEtapa[valor]) {
    return nivelAEtapa[valor];
  }

  // Manejo especial para "Program"
  if (campo === "Program") {
    const digimonSeleccionado = selectDigimon.value;
    if (digimonSeleccionado && specialProgramCases[digimonSeleccionado]) {
      const programsForDigimon = specialProgramCases[digimonSeleccionado];
      return "<ul>" +
        Object.entries(programsForDigimon)
          .map(function([digimon, program]) {
            if (Array.isArray(program)) {
              return program.map(function(p) {
                return "<li>" + digimon + ": " + p + "</li>";
              }).join('');
            } else {
              return "<li>" + digimon + ": " + program + "</li>";
            }
          })
          .join('') +
        "</ul>";
    }
  }

  // Manejo especial para "Xross"
  if (campo === "Xross") {
    const digimonSeleccionado = selectDigimon.value;
    if (digimonSeleccionado && specialxrossCases[digimonSeleccionado]) {
      const xrossForDigimon = specialxrossCases[digimonSeleccionado];
      return "<ul>" +
        Object.entries(xrossForDigimon)
          .map(function([digimon, drivers]) {
            const lista = Array.isArray(drivers) ? drivers : [drivers];
            return lista.map(function(driver) {
              return "<li>" + digimon + ": " + driver + "</li>";
            }).join('');
          })
          .join('') +
        "</ul>";
    }
  }

  // Manejo especial para "% Entrenamiento"
  if (campo === "% Entrenamiento") {
    const digimonSeleccionado = selectDigimon.value;
    if (digimonSeleccionado && specialEntrenamientoCases[digimonSeleccionado]) {
      const entrenamientoForDigimon = specialEntrenamientoCases[digimonSeleccionado];
      return "<ul>" +
        Object.entries(entrenamientoForDigimon)
          .map(function([digimon, valor]) {
            return "<li>" + digimon + ": " + valor + "</li>";
          })
          .join('') +
        "</ul>";
    }
  }
// Reemplaza la sección de "Comida" en la función traducirValor con esto:

// Manejo especial para "Bonus Comida" (flexible para ambos formatos)
if (campo === "Bonus Comida") {
  const digimonSeleccionado = selectDigimon.value;
  if (digimonSeleccionado && specialfoodcases[digimonSeleccionado]) {
    const foodForDigimon = specialfoodcases[digimonSeleccionado];
    
    // Formato nuevo simplificado: "Icemon": ["Verdura Congelada", "Hongo Congelado"]
    if (Array.isArray(foodForDigimon)) {
      const comidasTraducidas = foodForDigimon.map(function(comida) {
        return traducciones[currentLanguage][comida] || comida;
      });
      return comidasTraducidas.join(', ');
    }
    
    // Formato anterior complejo: "Icemon": { "Gotsumon": ["Verdura Congelada"], "Yuki Agumon": [...] }
    if (typeof foodForDigimon === 'object' && !Array.isArray(foodForDigimon)) {
      return "<ul>" +
        Object.entries(foodForDigimon)
          .map(function([digimon, comida]) {
            if (Array.isArray(comida)) {
              const comidasTraducidas = comida.map(function(c) {
                return traducciones[currentLanguage][c] || c;
              });
              return "<li>" + digimon + ": " + comidasTraducidas.join(', ') + "</li>";
            } else {
              const comidaTraducida = traducciones[currentLanguage][comida] || comida;
              return "<li>" + digimon + ": " + comidaTraducida + "</li>";
            }
          })
          .join('') +
        "</ul>";
    }
  }
}
  // Traducciones generales
  const idioma = traducciones[currentLanguage] || {};
  const traduccionesCampo = idioma.campos || {};
  const valorLimpio = String(valor).trim();

  if (traduccionesCampo[valorLimpio]) {
    return traduccionesCampo[valorLimpio];
  }

  if (idioma[valorLimpio]) {
    return idioma[valorLimpio];
  }

  return valor;
}



</script>
</body>
</html>